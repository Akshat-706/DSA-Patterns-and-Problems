<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reverse Pairs - CodeDSA</title>
 <link rel="stylesheet" href="../../CSS/AllProblems.css">
 <link rel="stylesheet" href="../../CSS/leetcodeButton.css"> 
 <link rel="stylesheet" href="../../CSS/copyToClipboard.css">
  <link rel="stylesheet" href="../../CSS/breadcrumb.css">
  <link rel="stylesheet" href="../../CSS/snake.css">
</head>

<body>

  <!-- Navbar -->
  <nav class="navbar">
    <a href="../../index.html" class="logo-container">
      <div class="logo-img">
        <img src="../../Images/logo.png" alt="Logo">
      </div>
      <div class="logo">CodeDSA</div>
    </a>
    <div class="nav-right">
      <ul class="nav-links">
        <li><a href="../../index.html">Home</a></li>
        <li><a href="../../about.html">About</a></li>
        <li><a href="../../contact.html">Contact</a></li>
      </ul>
      <button id="snakeToggle" class="snake-btn"><span style="margin-left: 20px;">Snake Cursor</span></button>
      <button id="darkModeToggle" class="dark-mode-btn">ðŸŒ™ Dark Mode</button>
    </div>
  </nav>

  <!-- Breadcrumb Navigation -->
  <div class="breadcrumb-container">
    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="../../index.html">Home</a></li>
        <li class="breadcrumb-item">
          <a href="../segmentTree.html">Segment Tree</a>
        </li>
        <li class="breadcrumb-item active" aria-current="page">
          Reverse Pairs
        </li>
      </ol>
    </nav>
  </div>

  <main>
    <h1>Reverse Pairs</h1>
    <!--Leetcode link-->
<p class="leetcode-link"><a href="https://leetcode.com/problems/reverse-pairs/" target="_blank" rel="noopener noreferrer">LeetCode #493 [Hard]</a></p>
<!--Print / Export control-->
<button onclick="window.print()" class="export-btn">ðŸ“„ Print/Save as PDF</button>
  <link rel="stylesheet" href="../../CSS/print.css" media="print">
    <!-- Problem Statement -->
    <section class="problem-section">
      <h2>Problem Statement</h2>
      <p>
        Given an integer array <strong>nums</strong>, return the number of <strong>reverse pairs</strong> in the array.
      </p>
      <p>
        A <strong>reverse pair</strong> is a pair <strong>(i, j)</strong> where:
      </p>
      <ul>
        <li>0 â‰¤ i < j < nums.length</li>
        <li>nums[i] > 2 * nums[j]</li>
      </ul>
      <p><strong>Example 1:</strong></p>
      <pre class="pseudo-code">
Input: nums = [1,3,2,3,1]
Output: 2
Explanation: The reverse pairs are:
(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1
(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1
      </pre><button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>

      <p><strong>Example 2:</strong></p>
      <pre class="pseudo-code">
Input: nums = [2,4,3,5,1]
Output: 3
Explanation: The reverse pairs are:
(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1
(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1
(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1
      </pre><button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>

      <p><strong>Constraints:</strong></p>
      <ul>
        <li>1 â‰¤ nums.length â‰¤ 5 * 10<sup>4</sup></li>
        <li>-2<sup>31</sup> â‰¤ nums[i] â‰¤ 2<sup>31</sup> - 1</li>
      </ul>
    </section>

    <!-- Approaches -->
    <section class="approach-section">
      <h2>Approach 1: Brute Force</h2>
      <p>
        <strong>Explanation:</strong> Check all pairs (i, j) where i < j and count pairs where nums[i] > 2 * nums[j].
      </p>
      <p>
        <strong>Time Complexity:</strong> O(nÂ²)
      </p>
      <p><strong>Space Complexity:</strong> O(1)</p>
      <pre class="pseudo-code">
function reversePairs(nums):
    count = 0
    n = length of nums
    
    for i = 0 to n-2:
        for j = i+1 to n-1:
            if nums[i] > 2 * nums[j]:
                count++
    
    return count
      </pre><button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>
<p class="think-line">ðŸ’¡ <strong>Think:</strong> Simple nested loop checks all pairs but too slow for large inputs.</p>

    </section>

    <section class="approach-section">
      <h2>Approach 2: Merge Sort (Optimal)</h2>
      <p>
        <strong>Explanation:</strong> Use modified merge sort to count reverse pairs while sorting. 
        During the merge step, count pairs where left[i] > 2 * right[j] before merging sorted halves.
      </p>
      <p><strong>Time Complexity:</strong> O(n log n)</p>
      <p><strong>Space Complexity:</strong> O(n) for auxiliary array</p>
      <pre class="pseudo-code">
function reversePairs(nums):
    return mergeSort(nums, 0, length-1)

function mergeSort(nums, left, right):
    if left >= right:
        return 0
    
    mid = left + (right - left) / 2
    count = mergeSort(nums, left, mid) + mergeSort(nums, mid+1, right)
    
    // Count reverse pairs
    j = mid + 1
    for i = left to mid:
        while j <= right and nums[i] > 2 * nums[j]:
            j++
        count += (j - (mid + 1))
    
    // Merge sorted halves
    merge(nums, left, mid, right)
    return count

function merge(nums, left, mid, right):
    temp = empty array
    i = left, j = mid + 1
    
    while i <= mid and j <= right:
        if nums[i] <= nums[j]:
            temp.append(nums[i++])
        else:
            temp.append(nums[j++])
    
    while i <= mid:
        temp.append(nums[i++])
    while j <= right:
        temp.append(nums[j++])
    
    // Copy back to original array
    for k = left to right:
        nums[k] = temp[k - left]
      </pre><button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>
<p class="think-line">ðŸ’¡ <strong>Think:</strong> Count pairs during merge sort's divide step, then merge sorted subarrays efficiently.</p>

    </section>

    <section class="approach-section">
      <h2>Approach 3: Binary Indexed Tree (BIT) / Fenwick Tree</h2>
      <p>
        <strong>Explanation:</strong> Use coordinate compression and BIT to efficiently count elements. 
        For each element, query count of elements > 2*nums[i] seen so far, then insert current element.
      </p>
      <p><strong>Time Complexity:</strong> O(n log n)</p>
      <p><strong>Space Complexity:</strong> O(n)</p>
      <pre class="pseudo-code">
function reversePairs(nums):
    // Coordinate compression
    sorted_nums = sorted(set of nums and 2*num for each num in nums)
    compress = map each value to its index in sorted_nums
    
    bit = BinaryIndexedTree of size len(sorted_nums)
    count = 0
    
    for i = length-1 down to 0:
        // Count elements > 2*nums[i]
        idx = compress[2 * nums[i]]
        count += bit.query(idx - 1)
        
        // Insert current element
        idx = compress[nums[i]]
        bit.update(idx, 1)
    
    return count

class BinaryIndexedTree:
    function update(index, delta):
        while index < size:
            tree[index] += delta
            index += index & (-index)
    
    function query(index):
        sum = 0
        while index > 0:
            sum += tree[index]
            index -= index & (-index)
        return sum
      </pre><button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>
<p class="think-line">ðŸ’¡ <strong>Think:</strong> Compress coordinates, traverse right-to-left counting larger elements with BIT.</p>

    </section>

    <section class="approach-section">
      <h2>Approach 4: Segment Tree</h2>
      <p>
        <strong>Explanation:</strong> Similar to BIT but using segment tree for range sum queries. 
        Coordinate compression maps values to indices, segment tree tracks count of each value seen.
      </p>
      <p><strong>Time Complexity:</strong> O(n log n)</p>
      <p><strong>Space Complexity:</strong> O(n)</p>
    <pre class="pseudo-code">// C++: Segment Tree (point update, range sum) + reversePairs using coordinate compression
class SegTree{
  vector&lt;int&gt; t;
public:
  SegTree(int n){ t.assign(4*n, 0); }

  int query(int ql, int qr, int idx, int l, int r){
    if(ql &gt; r || qr &lt; l) return 0;
    if(ql &lt;= l &amp;&amp; r &lt;= qr) return t[idx];
    int mid=(l+r)/2;
    return query(ql,qr,2*idx+1,l,mid) + query(ql,qr,2*idx+2,mid+1,r);
  }

  void update(int pos, int val, int idx, int l, int r){
    if(l==r){ t[idx] += val; return; }
    int mid=(l+r)/2;
    if(pos &lt;= mid) update(pos,val,2*idx+1,l,mid);
    else update(pos,val,2*idx+2,mid+1,r);
    t[idx]=t[2*idx+1] + t[2*idx+2];
  }
};

class Solution {
public:
  int reversePairs(vector&lt;int&gt;&amp; nums){
    int n = nums.size();
    // coordinate compression of nums and 2*nums
    vector&lt;long long&gt; vals; vals.reserve(2*n);
    for(long long x: nums){ vals.push_back(x); vals.push_back(2LL*x); }
    sort(vals.begin(), vals.end());
    vals.erase(unique(vals.begin(), vals.end()), vals.end());
    int m = vals.size();

    SegTree seg(m);
    long long ans = 0;
    for(int i=n-1;i&gt;=0;--i){
      long long target = 2LL*nums[i];
      // first index strictly greater than target
      int pos = upper_bound(vals.begin(), vals.end(), target) - vals.begin();
      if(pos &lt; m) ans += seg.query(pos, m-1, 0, 0, m-1);

      int idx = lower_bound(vals.begin(), vals.end(), (long long)nums[i]) - vals.begin();
      seg.update(idx, 1, 0, 0, m-1);
    }
    return (int)ans;
  }
};</pre><button class="copyToClipboard" onclick="copyToClipboard(this)">Copy!</button>
<p class="think-line">ðŸ’¡ <strong>Think:</strong> Segment tree provides flexible range queries with coordinate compression for value mapping.</p>

    </section>

  <a 
      href="https://leetcode.com/problems/reverse-pairs/" 
      class="leetcode-btn" 
      target="_blank">
      Solve on LeetCode
  </a>
    </main>
    <!-- Footer -->
    <footer>
      <p>&copy; 2025 Mrunalini Pachpute. All rights reserved.</p>
    </footer>
  
  <script src="../../index.js"></script>
  <script src="../../copyToClipboard.js"></script>
  <script src="../../JS/problemTracker.js"></script>
  </body>
</html>
